from datetime import datetime
import os
import logging
import uuid
import re
from typing import Dict, Any, Optional, List

from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.artifacts.in_memory_artifact_service import InMemoryArtifactService
from google.genai import types as adk_types
from supabase import create_client, Client

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TaskManager_DeliveryStaffAgent:
    """Minimal Task Manager for running tasks with the Delivery Staff Agent."""
    def __init__(self, agent):
        logger.info(f"Initializing TaskManager for agent: DeliveryStaffAgent")
        self.agent = agent

        # Initialize services
        self.session_service = InMemorySessionService()
        self.artifact_service = InMemoryArtifactService()

        # Runner
        self.runner = Runner(
            agent=self.agent,
            app_name="DeliveryStaffAgentApp",
            session_service=self.session_service,
            artifact_service=self.artifact_service
        )
        logger.info(f"ADK Runner initialized for app '{self.runner.app_name}'")

    def get_supabase_client(self) -> Optional[Client]:
        """Initialize and return Supabase client."""
        try:
            supabase_url = os.getenv("SUPABASE_URL")
            supabase_key = os.getenv("SUPABASE_ANON_KEY")
            
            if not supabase_url or not supabase_key:
                logger.error("Supabase credentials not found in environment variables")
                return None
            
            return create_client(supabase_url, supabase_key)
        except Exception as e:
            logger.error(f"Failed to initialize Supabase client: {e}")
            return None

    async def save_plan_to_db(self, plan_text: str, context: Dict[str, Any], session_id: str) -> bool:
        """Save Exter plan to Supabase database with essential fields only."""
        try:
            supabase = self.get_supabase_client()
            if not supabase:
                logger.error("Failed to get Supabase client")
                return False
            
            # Prepare minimal data for database
            db_data = {
                "email": context.get("email", ""),
                "name": context.get("name", ""),
                "role": context.get("role", ""),
                "department": context.get("department", ""),
                "plan": plan_text,  # Save the full plan text as generated by Jordan
                "created_at": datetime.utcnow().isoformat(),
                "consultation_type": "delivery_staff"
            }
            
            # Insert into database
            result = supabase.table("consultation_data").insert(db_data).execute()

            if result.data:
                consultation_id = result.data[0]['id']
                logger.info(f"Delivery Staff plan saved successfully for user: {context.get('email', 'unknown')} with ID: {consultation_id}")
                return consultation_id
            else:
                logger.error(f"Failed to save delivery staff plan: {result}")
                return False
                
        except Exception as e:
            logger.error(f"Error saving delivery staff plan to database: {e}")
            return False

    async def save_chat_history_to_db(self, conversation_history: List[Dict], consultation_id: int, email: str) -> bool:
        """Save conversation chat history to Supabase database."""
        try:
            supabase = self.get_supabase_client()
            if not supabase:
                logger.error("Failed to get Supabase client for chat history")
                return False
            
            if not conversation_history:
                logger.warning("No conversation history to save")
                return True
            
            # Prepare chat history data for batch insert
            chat_records = []
            for index, msg in enumerate(conversation_history):
                sender = msg.get('sender', 'unknown')
                message = msg.get('message', '')
                timestamp = msg.get('timestamp', datetime.utcnow().isoformat())
                
                # Map sender types (frontend might use different naming)
                if sender in ['user', 'human']:
                    sender = 'user'
                elif sender in ['ai', 'bot', 'agent', 'jordan']:
                    sender = 'ai'
                else:
                    sender = 'user'  # Default fallback
                
                chat_record = {
                    "consultation_id": consultation_id,
                    "email": email,
                    "sender": sender,
                    "message": message,
                    "message_order": index + 1,
                    "created_at": timestamp
                }
                chat_records.append(chat_record)
            
            # Batch insert chat history
            if chat_records:
                result = supabase.table("chat_history").insert(chat_records).execute()
                
                if result.data:
                    logger.info(f"Chat history saved successfully: {len(chat_records)} messages for consultation {consultation_id}")
                    return True
                else:
                    logger.error(f"Failed to save chat history: {result}")
                    return False
            else:
                logger.warning("No valid chat records to save")
                return True
                
        except Exception as e:
            logger.error(f"Error saving chat history to database: {e}")
            return False

    async def process_task(self, message: str, context: Optional[Dict[str, Any]] = None, session_id: Optional[str] = None) -> Dict[str, Any]:
        try:
            # Create session if not exists
            if not session_id:
                session_id = str(uuid.uuid4())

            conversation_history = context.get("conversationHistory", []) if context else []

            logger.info(f"CONVERSATION HISTORY: {conversation_history}")

            # For consultation questionnaires, use full conversation history
            # instead of trimming to maintain context throughout the session
            full_conversation_history = conversation_history
            
            # Only trim if conversation becomes extremely long (>20 messages)
            # to prevent token limits while maintaining good context
            if len(conversation_history) > 20:
                # Keep first 2 messages (intro) + last 16 messages for better context
                trimmed_conversation_history = conversation_history[:2] + conversation_history[-16:]
                logger.info(f"TRIMMED CONVERSATION HISTORY (keeping intro + last 16): {len(trimmed_conversation_history)} messages")
            else:
                trimmed_conversation_history = conversation_history
                logger.info(f"USING FULL CONVERSATION HISTORY: {len(trimmed_conversation_history)} messages")

            # Create session
            try:
                await self.session_service.create_session(
                    app_name="DeliveryStaffAgentApp",
                    user_id="default_user",
                    session_id=session_id,
                    state={}
                )
            except Exception as e:
                logger.warning(f"Session creation issue for DeliveryStaffAgent: {e}")

            # Extract user context from FULL conversation history for dynamic questioning
            from .agent_delivery_staff import extract_user_context, customize_question_for_context, get_next_question_id, get_question_by_id
            user_context = extract_user_context(full_conversation_history)
            logger.info(f"Extracted user context: {user_context}")

            # Format conversation history for the agent with context
            formatted_history = ""
            if trimmed_conversation_history:
                # Include all conversation messages for proper context
                for msg in trimmed_conversation_history:
                    sender = msg.get('sender', 'unknown')
                    message_text = msg.get('message', '')
                    if sender == 'user':
                        formatted_history += f"User: {message_text}\n"
                    elif sender == 'ai':
                        formatted_history += f"Assistant: {message_text}\n"
        
                formatted_history += f"\nCurrent user message: {message}"
                
                # Add context information for the agent with question customization hints
                context_info = []
                if user_context.get('campus'):
                    context_info.append(f"User works at {user_context['campus']} campus")
                if user_context.get('delivery_areas'):
                    context_info.append(f"User's delivery areas: {', '.join(user_context['delivery_areas'])}")
                if user_context.get('experience_years'):
                    context_info.append(f"Experience: {user_context['experience_years']}")
                if user_context.get('selected_other_tafe'):
                    context_info.append("User selected 'Other TAFE NSW area' - skip teaching-specific questions")
            
                # Add smart question handling instructions
                context_info.append("CUSTOMIZE QUESTIONS: Use campus-specific wording, filter matrix questions by user's areas, avoid redundant campus selection")
                
                if context_info:
                    formatted_history += f"\n[CONTEXT: {'; '.join(context_info)}]"
            else:
                formatted_history = f"Current user message: {message}"

            # Build request
            request_content = adk_types.Content(
                role="user",
                parts=[adk_types.Part(text=formatted_history)]
            )
            
            # Run agent
            events_async = self.runner.run_async(
                user_id="default_user",
                session_id=session_id,
                new_message=request_content
            )

            final_message = "No response generated."
            plan_saved = False
            consultation_id = None

            async for event in events_async:
                if event.is_final_response() and event.content and event.content.role == "model":
                    if event.content.parts and event.content.parts[0].text:
                        final_message = event.content.parts[0].text
                        logger.info(f"Agent response: {final_message}")

                        # Check if the last question (ID[74]) is being asked
                        if "ID[74]" in final_message:
                            # Generate a summary of the conversation
                            summary = ""  # Placeholder for the summary generated by another LLM
                            for msg in conversation_history:
                                sender = msg.get('sender', 'unknown')
                                message = msg.get('message', '')
                                summary += f"**{sender}:** \n{message}\n\n"

                            # Send the summarized conversation to the LLM for insights
                            insights_request_content = adk_types.Content(
                                role="user",
                                parts=[adk_types.Part(text=f"Summarized Conversation:\n{summary}")]
                            )

                            # Run the agent with the summarized conversation
                            insights_events_async = self.runner.run_async(
                                user_id="default_user",
                                session_id=session_id,
                                new_message=insights_request_content
                            )

                            async for insights_event in insights_events_async:
                                if insights_event.is_final_response() and insights_event.content and insights_event.content.role == "model":
                                    if insights_event.content.parts and insights_event.content.parts[0].text:
                                        insights = insights_event.content.parts[0].text
                                        logger.info(f"Insights generated: {insights}")
                                        break

                            await self.save_plan_to_db(summary, context, session_id)

                        # # Check if plan was generated
                        # if "[PLAN_GENERATED]" in final_message:
                        #     final_message = final_message.replace("[PLAN_GENERATED]", "").strip()
                            
                        #     # Save plan to database if context and email are available
                        #     if context and context.get("email"):
                        #         try:
                        #             consultation_id = await self.save_plan_to_db(final_message, context, session_id)
                        #             if consultation_id:
                        #                 plan_saved = True
                        #                 logger.info(f"Delivery Staff plan saved for user: {context.get('email')} with ID: {consultation_id}")

                        #                 # Save chat history after plan is saved successfully
                        #                 chat_saved = await self.save_chat_history_to_db(
                        #                     conversation_history, 
                        #                     consultation_id, 
                        #                     context.get("email")
                        #                 )
                                        
                        #                 if chat_saved:
                        #                     logger.info(f"Chat history saved successfully for consultation {consultation_id}")
                        #                 else:
                        #                     logger.error(f"Failed to save chat history for consultation {consultation_id}")
                        #             else:
                        #                 logger.error(f"Failed to save external stakeholder plan for user: {context.get('email')}")
                        #                 plan_saved = False
                        #         except Exception as save_error:
                        #             logger.error(f"Error during plan/chat saving: {save_error}")
                        #             plan_saved = False
                        #     else:
                        #         logger.warning("No email provided in context - plan and chat history not saved to database")

            return {
                "message": final_message,
                "status": "success",
                "session_id": session_id,
                "plan_saved": plan_saved,
                "consultation_id": consultation_id,
                "data": {
                    "plan_generated": "[PLAN_GENERATED]" in (event.content.parts[0].text if event.content and event.content.parts else ""),
                    "plan_saved": plan_saved,
                    "chat_history_saved": plan_saved  # Chat history is saved when plan is saved
                }
            }

        except Exception as e:
            logger.error(f"Error processing task: {e}")
            return {
                "message": f"Error: {str(e)}",
                "status": "error",
                "plan_saved": False,
                "consultation_id": None
            }

